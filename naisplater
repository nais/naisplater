#!/bin/bash
#
# util for processing golang templates

set -o pipefail

ENV="${1}"
TEMPLATES_DIR="${2}"
VARS_DIR="${3}"
OUTPUT_DIR="${4}"
DECRYPTION_KEY="${5:-''}"
NO_LABEL="${6}"

# tries to find "<no value>" (golang template marker for unresolved property) in provided file
# if found, it prints the location and exits with code 1
check_for_unresolved() {
  local file="${1}"
  if (( $(grep -c "<no value>" "${file}") > 0 )); then
    echo "error: found unresolved variable(s):" >&2
    grep -Hn "<no value>" "${file}"
    exit 1
  fi
}

add_created_by_label() {
  if [[ -z $NO_LABEL ]]; then
    cat - | yq write -d '*' - "metadata.labels[nais.io/created-by]" nais-yaml
  else
    cat -
  fi
}

# gets yaml from base file and merges/overrides specific for environment if present
get_yaml() {
  local file=${1}
  local base_file="${VARS_DIR}/${file}"
  local env_override_file="${VARS_DIR}/${ENV}/${file}"

  echo "env: ${ENV}"

  # merge if both files exist
  if [[  -f "${base_file}" &&  -f "${env_override_file}" ]]; then
    yq merge --overwrite "${base_file}" "${env_override_file}"
    return
  fi

  if [[ -f "${base_file}" ]]; then
    cat "${base_file}"
    return
  fi

  if [[ -f "${env_override_file}" ]]; then
    cat "${env_override_file}"
    return
  fi
}

# gets template files for base and specific for environment
get_template_files() {
  find "${TEMPLATES_DIR}" "${TEMPLATES_DIR}/${ENV}" -type f -maxdepth 1 2> /dev/null
}

decrypt() {
  IFS=''
  output=$(</dev/stdin)
  encrypted_vars=$(echo "${output}" | grep "\.enc: ")
  if [[ -z "${encrypted_vars}" ]]; then echo "${output}"; return; fi

  while read -r line || [[ -n "$line" ]]; do
      key=$(echo "${line}" | cut -d":" -f1)
      value=$(echo "${line}" | cut -d" " -f2)
      decrypted_value=$(echo "${value}" | openssl enc -d -aes-256-cbc -a -md md5 -k "${DECRYPTION_KEY}" || echo "unable to decrypt: ${line}" 1>&2)
      stripped_key=${key//.enc/}
      output=$(echo -e "${output}\n${stripped_key}: ${decrypted_value}")
  done <<< "${encrypted_vars}"
  
  echo "${output}"
}

print_help() {
  cat <<EOF
usage: naisplater [environment] [templates_dir] [variables_dir] [output_dir] ([decryption key])

environment           specifies which subdirectory in <templates_dir> to include files from,
                      and which subdirectory in <variables_dir> to merge/override yaml with
templates_dir         directory containing go template files. Environment specific files goes into <templates_dir>/<environment>
variables_dir         directory containing yaml variable files. Environment specific overrides must go into sub dir <variables_dir>/<environment>
output_dir            folder to output processed templates (if folder exists with files, naisplater will not run)
decryption_key        secret to use for decrypting secret variables
EOF
}

main() {

  # TODO: use getopts and flags instead
  if [[ "${1}" == "-h" || "${1}" == "--help" ]]; then print_help && exit 0; fi

  if [[ "${#}" -lt "4" ]]; then
    echo "error: must provide at least four arguments" >&2
    print_help
    exit 1
  fi

  # ensure output dir exists
  mkdir -p "${OUTPUT_DIR}"

  if find "${OUTPUT_DIR}" -mindepth 1 | read -r; then
    echo "error: output directory ${OUTPUT_DIR} is not empty, clean up before running"
    exit 1
  fi 
  
  for file_path in $(get_template_files); do
    local file_name
    file_name=$(basename "${file_path}")  
    local output_file="${OUTPUT_DIR}/${file_name}"

    2>& echo "Parsing ${file_path} to create ${output_file}..."
    get_yaml "${file_name}" | decrypt | gotpl "${file_path}" | add_created_by_label > "${output_file}"

    ret_val=$?
    if [ $ret_val -ne 0 ]; then
      exit $ret_val
    fi

    check_for_unresolved "${output_file}"
  done
}

main "$@"
